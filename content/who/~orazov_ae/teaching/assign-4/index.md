---
title: 4-Symbol-Table
customdate: 2023 Jan 31 (火) 01:12PM
---

# 4. Symbol Table

Перед разработчиком компилятора (пока что интерпретатора) стоит слудующая
задача:

> Где хранить и как обращаться с переменными и функциями?

```
fun f x = 2 * x;

fun main argc argv = f(0);
```

Попытаемся представить себе, какое поведение мы бы ожидали от такого кода (пока
что считаем, что вызывать можно только по имени).


```
    =========        ================
    | f | x |        | main | argc, |
    +++++++++        |      | argv  |
    |   *   |        ++++++++++++++++
    |  / \  |        |              |
    | 2   x |        |   CALL `f`   |
    =========        |      |       |
                     |      0       |
                     |              |
                     ================
```

|  Typechecker             |  Interpreter    |
| ------------------------ | --------------  |
| найти тип `f`            | найти тело `f`  |
|                          |    Г ⊢ x ← 0    |
| сравнить типы агрументов | `eval(f->body)` |


Мы хотим простую вещь: по идентификатору понимать информацию о нём.


В таком простом языке как Étude даже нет необходимости для каких-то сложных
манипуляций. В большинстве случаев мы хотим от *binding*-a только его тело.
Прочитайте, например, как хранят информацию в компиляоре язка Haskell
[GHC: No Symbol Table](https://www.aosabook.org/en/ghc.html)

Посмотрите, как таблицы символов реализованы в других компиялторах:
- [cproc/cc.h: scope, decl](https://github.com/michaelforney/cproc/blob/master/cc.h#L265-L296)
- ...

**Ключевые слова**: *lexical scope, shadowing, symbol table, lookup, binding,
cactus stack.*

## Symbol Table Builder

Чтобы поддерживать семантику языка *Étude*, вам предлагается сделать построение
таблицы символов отдельным проходом компилятора. Это будет иметь эффект того,
что все символы в программе оживают **одновременно**. Тогда в языке нет
необходимости иметь **forward declaration**, как в *Си* или *OCaml*.

## API

Здесь предполагается, что *visitor* при построении таблицы поддерживает
указатель на ***текущий scope***, который везде передаётся неявным параметром.

| Name     | Type                          | Description                       |
| ------   | ----------------------------- | --------------------------------- |
| `lookup` | `string_view -> Symbol*`      | Достать символ из таблицы         |
| `bind`   | `string_view -> Symbol -> ()` | Положить символ в текущий *scope* |
| `enter`  | ` -> ()`                      | Создать новый слой таблицы символов, подвесить его к текущему
| `exit`   | ` -> ()`                      | Вернутся в предыдущий *scope*     |

## Задание

1. Прочитайте часть главы про *scope* [Crafting Interpreters: Scope](https://craftinginterpreters.com/statements-and-state.html#scope)
2. Придумайте как и что хранить в структуре `Symbol`.
3. Реализуйте древесную структуру *Scope*-ов c указателями на родителей.
4. Создайте `SymbolTableBuilder`*—visitor*

## Playground

1. Используя похожие идеи поддержите в интерпретаторе *state* и *функции*

В слудующей главе интерпретатор превратится в **Typecheker**.

## Реализация

Будьте осторожны и избегайте циклических зависимостей между `Symbol`,
`Context`, `ScopeLayer`

## Комментарии


Типы определяемых выражений `x: Int` и их тела `f → x + 2` хранятся в таблице
символов. С другой стороны, для кодогенерации тоже удобно знать, какого типа
является выражение, поэтому я также храню указатель на тип **прямо в AST**.
[Related: Trees That Grow](https://www.microsoft.com/en-us/research/uploads/prod/2016/11/trees-that-grow.pdf)

